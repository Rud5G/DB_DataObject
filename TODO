Current TODO list:
----------------------------------
Issue: Table Rebuilds

If you modify the database table, then DB_DataObject will be unaware of the change until you
run createTables.php again.


Solution:
if the 'production' option is off, then it should rebuild the table information at the same time as loading
the table description. and compare the current definition to the new generated one...

-----------------------------------
Issue: More detailed cached table information

make available an extra ini file database.details.ini, which contains
[table]
column = type:size:notnull: etc. 
from the tableInfo() call

to allow quick lookup/retrieval of this data for any purpose...


-----------------------------------
Issue: Replace 

Mysql has a nice replace feature, It would be nice to have in dataObjects

Solution:
Add a method, if the database is mysql, use the native 'REPLACE call'
otherwise, do a select on ID then insert|update..

----------------------------------
Issue: Delete -- DONE 0.7

delete can be called in many ways:

$object->get(12);
$object->delete();
in which case deleting on the primary key is desired.

$object->colour = 'red';
$object->delete();
in which case deleting on the _build_condition is desired
(eg. when the primary key is not set)

$object->whereAdd("colour like 'r%');
$object->delete(TRUE);
works OK - just uses the where condition, not the values.


 

----------------------------------
Issue: Crosstable Joins

Althought the main documents indicate that a join version ended up being too complex, this
was based on doing multiple joins on many tables. - It has been suggested (and code provided),
that doing a simpler version may be possible:

One suggestion by Stejn de Reede was to do this

$product = new DataObjects_Product();
$product->get(24);
$img = new DataObjects_Image();
$img->orderBy('product_image.sort');
$product->getCrossLink($img);

which would result in the queries:
SELECT * FROM produce WHERE id = 24;

SELECT * from image
    INNER JOIN product_image
    ON product_image.image  = image.id
    WHERE product_image.product_id = 24
    ORDER BY product_image.sort;
   


** Reservations:
* introduction of 'magic table' product_image, that is not clear from the code.
* use of assumed defaults like id and column names product_id which are 'magicly generated' -
  The initial links code used this, and proved slightly troublesome - the links.ini file solved alot of this.
* query results have little relation to the object that they are exectuted on. (eg. product object is filled with image and product_image join results)


From a totally abstract view (thinking out loud), It would be clearer to do something like:

$image              = new DataObjects_Image;
$productimage       = new DataObjects_Productimage
$productimage->productid = 24;

$image->addJoin( $productimage );
$image->orderBy('productimage.sort')
$image->findJoin();


Which would build:

SELECT * from image

    INNER JOIN productimage
    ON productimage.image  = image.id
   
    WHERE productimage.productid = 24
    ORDER BY productimage.sort;
   
   

$productimage = new DataObjects_Productimage;
$product      = new DataObjects_Product;
$image        = new DataObjects_Image

$product->id = 24;

$productimage->addJoin( $image   );
$productimage->addJoin( $product );

$productimage->orderBy('productimage.sort')
$productimage->findJoin();



Which would build:

SELECT * from productimage
    INNER JOIN image
    ON productimage.image  = image.id

    INNER JOIN product
    ON productimage.product  = product.id

    WHERE product.id = 24
    ORDER BY productimage.sort;
   

** I've no idea is this query would work or is valuable - so it needs a bit of testing.




Based on a configuration: (joins.ini) // or could be shared with links.ini ?
[productimage]
;; many to 1
;; joins table productimage:image to image:id
image = image:id
;; joins table productimage:product to product:id
product = product:id

 




