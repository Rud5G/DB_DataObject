overview of methods in DB_DataObject and issues relating to MDB




General Issues about behaviour

-print_r()
DataObjects relies on the ability to have a small clean print_R() output - this must be maintained.
at present all privates _* are visable on print_r, 




Private Vars:

to reduce this - the private array
 _query[condition|group_by|order_by|limit|select|join] will replace the current relivant _* elements.
This will enable you to 
    find(array(
        'condition'=>'id=21',
        'group_by' =>'name',
        'order_by' =>'name',
        'limit'    => array(1,2)
        'select'   => 'id,name
        ));
        

__table,
_connection[database|dsn|id]


Step by step..

Connection:

At present a long and convoluted method manages the connection 
- connections are always stored in $_DB_DATAOBJECT['CONNECTIONS']
since connections are not likely to incur much of the time - it would be better to move to a position where
$dataobject->connect($dsn='') always returns the objects connection (or connects it..)
since the print_r() output does not want to display the connection
    $_DB_DATAOBJECTS['options']['dsn'] is the default dsn.
    $_DB_DATAOBJECTS['options']['table_*'] is a mapping of table to database.
    $_DB_DATAOBJECTS['options']['database_*'] is a mapping of databases to dsn.
    
    $_DB_DATAOBJECTS['connections_id'][0...9] should store a dsn of a connection.
    
    $dataobject->_connection['id'] = an abnormal id.
     = an abnormal id.
    
    // rules of connections
    
    A)  USE DSN
        is the dsn argument set
        is dsn in $_DB_DATAOBJECTS['connections_id'][0...9] 
            != ..  add it 
        set $dataobject->_connection['id']
        return REAL connect with it.
         
    A1) if the dsn is an object, use getDSN(), and 
        return self->connect with it.
    
    
    B)  USE ALREADY CONNECTED ID.
        is $dataobject->_connection['id'] 
        is $_DB_DATAOBJECTS['connections_id'][0...9] set?
            - yes - return self call with it.
            - no carry on..
        
   
    C)  USE SELF _connection['dsn']
        is $dataobject->_connection['dsn'] self call with it.
    
    
    D) USE CONFIG DATABASE dsn
        is $dataobject->_connection['database'] set 
            -- is $_DB_DATAOBJECTS['options']['database_*'] set
                - yes self call with it.
            
    
    E) USE TABLE MAPPING CONFIG
        is  $_DB_DATAOBJECTS['options']['table_*'] set
        lookup in  $_DB_DATAOBJECTS['options']['database_*']
    
    F) FALL BACK TO DEFAULT.
        self call with $_DB_DATAOBJECTS['options']['dsn']
        
        
_query should be possible to remove.
    as most query's can be preformed by 
    $con = $this->connect();
    $con->query(...)

_getTable:


currently returns an array of column name => type.
this is stored in an ini file and loaded at initialization into
    $_DB_DATAOBJECT['INI'][$this->_database][$this->__table];

-- should be replaced with
    $_DB_DATAOBJECT['SCHEMA'][$this->_database][$this->__table];
    and should return 

        [databasename]
                [tablename]
                    [fields]
                        [fieldname]
                                [type]
                                [notnull]
                                [default]
                    [sequence]
                        [fieldname] 
                            [name] => [sequence_name]
                    [indexes]
                        [fieldname] 
                            [name] => [index_name]  
                            [sorting] => [index_name]  
                        [fieldname]
                    


<wddxPacket version='1.0'>
  <header/>
  <data>
    <struct>
      <var name='databases'>
        <struct>
          <var name='demo_database'>
            <struct>
              <var name='fields'>
                <struct>
                  <var name='demo_id'>
                    <struct>
                      <var name='type'><string>int</string></var>
                      <var name='notnull'><string>true</string></var>
                    </struct>
                  </var>
                  <var name='demo_name'>
                    <struct>
                      <var name='type'><string>string</string></var>
                      <var name='notnull'><string>false</string></var>
                    </struct>
                  </var>
                </struct>
              </var>
              <var name='sequences'>
                <struct>
                  <var name='demo_id'> <!-- on field -->
                    <struct>
                      <var name='name'><string>demo_sequence</string></var>
                      <var name='unique'><string>0</string></var>
                    </struct>
                  </var>
                </struct>
              </var>
                <var name='indexes'>
                <struct>
                  <var name='demo_id'> <!-- on field -->
                    <struct>
                      <var name='name'><string>demo_index</string></var>
                      <var name='sorting'><string>assending</string></var>
                    </struct>
                  </var>
                </struct>
              </var>
             </struct>
           </var>
        </struct>
      </var>
    </struct>
  </data>
</wddxPacket>


this means that get_keys and get_table will be irrelevant. and just checking
    if (empty($_DB_DATAOBJECT['databases']) {
        $this->_loadDefinitions();
    }
    is required prior to
    
    $fields = $_DB_DATAOBJECT['databases']['demo_database']['fields'];
    echo $fields[$column]['type']
    
    by calling  $dataObject->refreshDefinitions()
    a re-engineer database call can be used to generate the updated definition.
    
    // 



// DB_DataObjects and getFloatValue() etc.

rather than the cheesy INT/STR checks that dataobjects currently does, MDB offers a whole new range 
of data formating tricks for SQL creation.

DataObjects has a number of ways of setting data:

$object->xxxx = 1
$object->setFrom(array('xxxx'=>1)); // or $obj->xxx=1;$object->setFrom($obj);

and while it's fetching..

for fetching:
 - for user output - stuff like
    $object->birth_date
    // it would be nice if the user could retrieve formated versions somehow.. ????
    ** use convertResultRow()
    
 - for building queries 
    - will have to relay into $mdb->getValue($fields[$column]['type'],$this->$column);
    - have to do isset, and check if notnull is set on the schema..
    - nulls map to 
 
 - for building updates/inserts
    same rules apply
    // use setParam?
    INSERT INTO (' . implode(',',array_keys($set))) . ') VALUES ('. implode(',',array_fill(0,count($set),'?')) . )';
    // use setParam?
    UPDATE xxxx SET (substr(2,implode('=?,',array_keys($set))).=?) WHERE $condition;
    
    
    DELETE FROM XXX WHERE $condition
    
    SELECT {$this->_conditions['select']} FROM XXX WHERE $condition['where']....



Overloading - making setXXX and getXXX work by default.

there are some situations where getXXX and setXXX working by default would be usefull:
eg. 
$object->getBirth_Date();
// would return the database value to start with
// but later could be modified to return a nice formated version...


.. setFrom should automatically relay into these methods...??????



    
setXXXX() {

// only called on undefined setXXXX/getXXXXX methods.
// 
function __call($method,$params,&$return) {
    $type = strtolower(substr($method,0,3);
    if ($type) != 'set') && strtolower($type) {
        die('Undefined Method!.....');
    }
    $method = substr($method,3);
    if ($method{0} == '_') {
        die('Undefined Method!.....');
    }
    if (!isset(get_object_vars($method)) {
        die('Undefined Method!.....');
    }
    if ($type == 'get') {
        $return = $this->$method;
        return true;
    }
    $this->$method = $params[];
    $return = true;
    return true;
}
    
    
     
     
     




















        